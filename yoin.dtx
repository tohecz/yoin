% \iffalse meta-comment
%!TeX program = T_do_dtx
% 
% This part is not going to appear anywhere so is good for 'header'
% information.
%
%% These lines, starting with two "%", will be extracted so can be used
%% to copy some kind of header into target (.sty) files: the team .dtx
%% use this to dump the copyright header from the meta-comment block into
%% the output.
%
%<*driver>
\documentclass{l3doc}

\usepackage[vmargin=1in,hmargin={2in,1in},a4paper,landscape]{geometry}
\usepackage{lmodern,anttor}
\usepackage{xcolor}

\newcommand\T[1]{{\let\\\textbackslash\texttt{#1}}}
\newcommand\p[1]{\texttt{\##1}}

\DisableCrossrefs
\CodelineNumbered
\def\theCodelineNo{{\color{black}\normalfont\fontseries{sb}\selectfont\footnotesize\arabic{CodelineNo}}}
\def\MacroFont{\ttfamily\color{blue}}

% Whatever packages here
%
% Might include
% \usepackage{\jobname}
%
% Very handy is
% \usepackage[numbered]{hypdoc} % hyperref for l3doc
%
% You might want the following
%\EnableCrossrefs
%\CodelineIndex
%\RecordChanges
\begin{document}
  \DocInput{\jobname.dtx}
\end{document}
%</driver>
% \fi
%
% ^^A Comments in the documentation part start ^^A
%
% ^^A If you use the extracted package itself you can do
% \GetFileInfo{\jobname.sty}
% ^^A and define \filedate, etc.
%
% ^^A Meta data for the package
% \title{\pkg{mypkg}\thanks{^^A
%   This file describes version \fileversion, last revised \filedate.^^A
% }}
% \author{^^A
%   Tom Hejda\thanks{E-mail: tohecz@gmail.com}^^A
% }
% \date{Released \filedate}
%
% \section{User documentation}
%
% User documentation would appear here.
%
% ^^A This will appear at the end of the PDF, which might or might not include
% ^^A the typeset code
% \StopEventually{^^A
%   \PrintChanges
%   \PrintIndex
% }
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \section{Package header}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% We load the required packages needed for \LaTeX3, and the package header.
%
% \begin{macrocode}
%<*package>
\RequirePackage{expl3,l3keys2e,xparse}
\ProvidesExplPackage{yoin}{2016/02/28}{v0.0.1}{Joining articles into issues}
%    \end{macrocode}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \section{General macros}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%    \begin{macro}{\yoin_seq_gappend_clist:Nn}
%    Globally append \T{clist} \p2 to \T{seq} \p1.
%    \begin{macrocode}
\cs_new_protected:Nn \yoin_seq_gappend_clist:Nn {
	\seq_set_from_clist:Nn \l__yoin_tmpa_seq { #2 }
	\seq_gconcat:NNN #1 #1 \l__yoin_tmpa_seq
}
%    \end{macrocode}
%    \end{macro}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \section{Key--value interface for the package setup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% First, we define the variables to store the keys.
%    \begin{macrocode}
\bool_new:N \g_yoin_subprocess_bool
\bool_new:N \g_yoin_dryrun_bool
\bool_new:N \g_yoin_onlyflags_bool
\bool_new:N \g_yoin_onlytags_bool
%    \end{macrocode}
%    \begin{macrocode}
\seq_new:N \g_yoin_flags_seq
\seq_new:N \g_yoin_tags_seq
\seq_new:N \g_yoin_onlyflags_seq
\seq_new:N \g_yoin_onlytags_seq
%    \end{macrocode}
%    \begin{macrocode}
\msg_new:nnnn { yoin } { unknown-flag }
	{ The ~ flag ~ `#1' ~ is ~ unknown ~ to ~ `yoin'. }
	{ You ~ either ~ misspelled ~ it ~ or ~forgot ~ to ~ declare ~ it. }
%    \end{macrocode}
%    \begin{macrocode}
\msg_new:nnnn { yoin } { unknown-tag }
	{ The ~ tag ~ `#1' ~ is ~ unknown ~ to ~ `yoin'. }
	{ You ~ either ~ misspelled ~ it ~ or ~forgot ~ to ~ declare ~ it. }
%    \end{macrocode}
% The keys themselves:
%    \begin{macrocode}
\keys_define:nn { yoin / general } {
%    \end{macrocode}
% Booleans:
%    \begin{macrocode}
	dryrun .bool_gset:N = \g_yoin_dryrun_bool,
	dryrun .initial:n = { false },
%    \end{macrocode}
%    \begin{macrocode}
	subprocess .bool_gset:N = \g_yoin_subprocess_bool,
	subprocess .initial:n = { false },
%    \end{macrocode}
% Keys whose \T{clist} values are appended to a \T{seq}:
%    \begin{macrocode}
	defineflags .code:n = \yoin_seq_gappend_clist:Nn \g_yoin_flags_seq { #1 },
%    \end{macrocode}
%    \begin{macrocode}
	definetags .code:n = \yoin_seq_gappend_clist:Nn \g_yoin_tags_seq { #1 },
%    \end{macrocode}
% A \T{clist} key is stored in a \T{seq}, also, a corresponding \T{bool} is set true:
%    \begin{macrocode}
	onlyflags .code:n =
		\seq_gset_from_clist:Nn \g_yoin_onlyflags_seq { #1 }
		\bool_gset_true:N \g_yoin_onlyflags_bool
		,
%    \end{macrocode}
%    \begin{macrocode}
	onlytags .code:n =
		\seq_gset_from_clist:Nn \g_yoin_onlytags_seq { #1 }
		\bool_gset_true:N \g_yoin_onlytags_bool
		,
%    \end{macrocode}
%    \begin{macrocode}
}
%    \end{macrocode}
%
% Process key options given to the package.
% We \emph{do not want to process any options given to the class}.
% Whence \T{\\ProcessKeysPackageOptions} and not \T{\\ProcessKeysOptions}.
%    \begin{macrocode}
\ProcessKeysPackageOptions { ctuthesis }
%    \end{macrocode}
%
% Allow keys to be set later. We define both a \LaTeX3 interface and an xparse UI wrapper.
%    \begin{macrocode}
\cs_new_protected:Nn \yoin_setup:n {
	\keys_set:nn { yoin / general } { #1 }
}
%    \end{macrocode}
%    \begin{macrocode}
\NewDocumentCommand \yoinSetup { R[]{} } {
	\yoin_setup:n { #1 }
}
%    \end{macrocode}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \section{\T{\\yoinAdd} macro --- adding articles to the issue}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% The key--value interface. In this case, we basically only store the keys for each article in a \T{prop}.
% First, an interface for setting the keys for the articles.
% \T{\\g_yoin_articles_seq} stores the list of the existing articles.
% \T{\\yoin_article_prop:n} returns the name of the \T{prop} for the given article;
%  \emph{no check for existence is done at this place.}
%    \begin{macrocode}
\seq_new:N \g_yoin_articles_seq
%    \end{macrocode}
%    \begin{macrocode}
\cs_new:Nn \yoin_article_prop:n {
	g__yoin_article_#1_prop
}
\cs_generate_variant:Nn \yoin_article_prop:n { V }
%    \end{macrocode}
% For processing \T{\\yoinAdd}, we first set up a \T{tl} to contain the name of the article, then create the \T{prop},
%  and finally use \T{l3keys} to fill in the \T{prop}.
% Note that if an article is added twice, an error is issued, if the error is ignored, the article is not added but
%  the properties are set.
%    \begin{macrocode}
\tl_new:N \l__yoin_yoinadd_currentarticle_tl
%    \end{macrocode}
%    \begin{macrocode}
\cs_new_protected:Nn \__yoin_yoinadd_storekey:nn {
	\prop_gput:cnn { \yoin_article_prop:V \l__yoin_yoinadd_currentarticle_tl } { #1 } { #2 }
}
%    \end{macrocode}
%    \begin{macrocode}
\cs_new_protected:Nn \yoin_yoinadd:nn {
	\seq_if_in:NnTF \g_yoin_articles_seq { #1 } {
		\msg_error:nnn { yoin } { yoinadd / duplicatearticle } { #1 }
	} {
		\seq_gput_right:Nn \g_yoin_articles_seq { #1 }
		\prop_new:c { \yoin_article_prop:n { #1 } }
	}
	\tl_set:Nn \l__yoin_yoinadd_currentarticle_tl { #1 }
	\keys_set:nn { yoin / yoinadd } { #2 }
}
%    \end{macrocode}
%    \begin{macrocode}
\NewDocumentCommand \yoinAdd { m O{} } {
	\yoin_yoinadd:nn { #1 } { #2 }
}
%    \end{macrocode}
% The error message for adding a duplicate article.
%    \begin{macrocode}
\msg_new:nnn { yoin } { yoinadd / duplicatearticle }
	{ The ~ article ~ "#1" ~ has ~ been ~ already ~ processed ~ by ~ \token_to_str:N \yoinAdd ~.}
%    \end{macrocode}
% The keys here are pretty simple; each defined key just stores its value in the \T{prop}.
% We recall that \T{\#1} is the key and \T{\#\#1} is the value.
%    \begin{macrocode}
\clist_map_inline:nn { forceopenany, forceopenright } {
	\keys_define:nn { yoin / yoinadd } {
		#1 .code:n = \__yoin_yoinadd_storekey:nn { #1 } { ##1 },
	}
}
%    \end{macrocode}
% However, for the \T{tag} key, we check that the tag exists.
%    \begin{macrocode}
\keys_define:nn { yoin / yoinadd } {
	tag .code:n =
		\__yoin_error_if_tag_undefined:n { #1 }
		\__yoin_yoinadd_storekey:nn { tag } { #1 }
		,
}
%    \end{macrocode}
% ^^A    \begin{macrocode}
% ^^A    \end{macrocode}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \section{Blablabla}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%    \begin{macrocode}
\prg_new_protected_conditional:Nnn \yoin_if_tag_defined:n { T, F, TF } {
	\seq_if_in:NnTF \g_yoin_tags_seq { #1 } { \prg_return_true: } { \prg_return_false: }
}
\prg_new_protected_conditional:Nnn \yoin_if_flag_defined:n { T, F, TF } {
	\seq_if_in:NnTF \g_yoin_flags_seq { #1 } { \prg_return_true: } { \prg_return_false: }
}
\cs_new_protected:Nn \__yoin_error_if_tag_undefined:n {
	\yoin_if_tag_defined:nF { #1 } { \msg_error:nnn { yoin } { unknown-tag } { #1 } }
}
\cs_new_protected:Nn \__yoin_error_if_flag_undefined:n {
	\yoin_if_flag_defined:nF { #1 } { \msg_error:nnn { yoin } { unknown-flag } { #1 } }
}
\keys_define:nn { yoin / yoinshell } {
%    \end{macrocode}
%    \begin{macrocode}
	flag .code:n =
		\__yoin_error_if_flag_undefined:n { #1 }
		\bool_if:NT \g_yoin_onlyflags_bool {
			\seq_if_in:NnF \g_yoin_onlyflags_seq { #1 } {
				\keys_set:nn { yoin / yoinshell } {
					ignore = true
				}
			}
		}
		,
%    \end{macrocode}
%    \begin{macrocode}
	ignore .bool_set:N = \l_yoin_yoinshell_ignore_bool,
	ignore .initial:n = { false },
%    \end{macrocode}
%    \begin{macrocode}
}
%    \end{macrocode}
%
%  \begin{macro}{\bla}
%    \begin{macrocode}



\cs_new_protected:Nn \yoin_keys_set_from_file:nn {
	\tl_set_from_file:Nnn \l_tmpa_tl { } { #2 }
	\keys_set:nV { #1 } \l_tmpa_tl
}
\cs_generate_variant:Nn \keys_set:nn { nV }

\cs_new:Nn \yoin_blabla: {
	Blabla
}

%    \end{macrocode}
%  \end{macro}
%
%    \begin{macrocode}
%</package>
%    \end{macrocode}
%
% \Finale