% \iffalse meta-comment
%!TeX program = T_do_dtx
% 
% This part is not going to appear anywhere so is good for 'header'
% information.
%
%% These lines, starting with two "%", will be extracted so can be used
%% to copy some kind of header into target (.sty) files: the team .dtx
%% use this to dump the copyright header from the meta-comment block into
%% the output.
%
%<*driver>
\documentclass{l3doc}

\ExplSyntaxOn

\cs_set_protected_nopar:Nn \__codedoc_macro_end_style:n { }

\ExplSyntaxOff

\usepackage[vmargin=0.8in,hmargin={2.5in,0.8in},marginparsep=0.1in,marginparwidth=2.3in,a4paper,landscape]{geometry}
\usepackage{lmodern,anttor}
\usepackage{xcolor}

\DisableCrossrefs
\CodelineNumbered
\def\theCodelineNo{{\color{black}\normalfont\fontseries{sb}\selectfont\footnotesize\arabic{CodelineNo}}}
\def\MacroFont{\ttfamily\color{blue}}

% Whatever packages here
%
% Might include
% \usepackage{\jobname}
%
% Very handy is
% \usepackage[numbered]{hypdoc} % hyperref for l3doc
%
% You might want the following
%\EnableCrossrefs
%\CodelineIndex
%\RecordChanges
\begin{document}
  \DocInput{\jobname.dtx}
\end{document}
%</driver>
% \fi
%
% ^^A Comments in the documentation part start ^^A
%
% ^^A If you use the extracted package itself you can do
% \GetFileInfo{\jobname.sty}
% ^^A and define \filedate, etc.
%
% ^^A Meta data for the package
% \title{\pkg{mypkg}\thanks{^^A
%   This file describes version \fileversion, last revised \filedate.^^A
% }}
% \author{^^A
%   Tom Hejda\thanks{E-mail: tohecz@gmail.com}^^A
% }
% \date{Released \filedate}
%
% ^^A \section{User documentation}
%
% ^^A User documentation would appear here.
%
% ^^A This will appear at the end of the PDF, which might or might not include
% ^^A the typeset code
% \StopEventually{^^A
%   \PrintChanges
%   \PrintIndex
% }
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \section{Package header}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%    \begin{macrocode}
%<*package>
%<@@=yoin>
%    \end{macrocode}
% Necessary packages: First, \LaTeX3 stuff.
%    \begin{macrocode}
\RequirePackage{expl3,l3keys2e,l3regex,xparse}
%    \end{macrocode}
% From |zref| bundle, for computing the total number of pages of an article.
%    \begin{macrocode}
\RequirePackage{zref-totpages}
%    \end{macrocode}
% We need the absolute paths. This also means we need |-recorder| option to |pdflatex|.
%    \begin{macrocode}
\RequirePackage[abspath]{currfile}
%    \end{macrocode}
% For including PDF files.
%    \begin{macrocode}
\RequirePackage{pdfpages}
%    \end{macrocode}
% Package header.
%    \begin{macrocode}
\ProvidesExplPackage{yoin}{2016/02/28}{v0.0.1}{Joining articles into issues}
%    \end{macrocode}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \section{General macros}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Macros not necessarily related to the package; moreorless an addition to \LaTeX3.
% \begin{macro}{\yoin_seq_gappend_clist:Nn}
%    Globally append |clist| |#2| to |seq| |#1|.
%    \begin{macrocode}
\seq_new:N \l_@@_seq_tmpa_seq
\cs_new_protected:Nn \yoin_seq_gappend_clist:Nn {
	\seq_set_from_clist:Nn \l_@@_seq_tmpa_seq { #2 }
	\seq_gconcat:NNN #1 #1 \l_@@_seq_tmpa_seq
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\yoin_keys_set_from_file:nn}
% Read a file |#2| containing a key--value list and set the keys for |#1|.
% No checks are done here, nothing like comments could be used, the keys should be separated by a comma
%  (and spaces of course as needed).
%    \begin{macrocode}
\tl_new:N \l_@@_keys_tmpa_tl
\cs_generate_variant:Nn \keys_set:nn { nV }
\cs_new_protected:Nn \yoin_keys_set_from_file:nn {
	\tl_set_from_file:Nnn \l_@@_keys_tmpa_tl { } { #2 }
	\keys_set:nV { #1 } \l_@@_keys_tmpa_tl
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\yoin_keyval_parse_from_file:nn}
% Read a file |#2| containing a key--value list and set the keys for |#1|.
% No checks are done here, nothing like comments could be used, the keys should be separated by a comma
%  (and spaces of course as needed).
%    \begin{macrocode}
\cs_generate_variant:Nn \keyval_parse:NNn { NNV }
\cs_new_protected:Nn \yoin_keyval_parse_from_file:NNn {
	\tl_set_from_file:Nnn \l_@@_keys_tmpa_tl { } { #3 }
	\keyval_parse:NNV #1 #2 \l_@@_keys_tmpa_tl
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{msg: boolean-values-only}
% Message for a non-boolean passed to a bool key.
%    \begin{macrocode}
\msg_new:nnn { yoin } { boolean-values-only }
	{ Key ~ '#1' ~ accepts ~ boolean ~ values ~ only.}
%    \end{macrocode}
% \end{macro}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \section{Key--value interface for the package setup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% First, we define the variables to store the keys.
% \begin{macro}{ \g_yoin_subprocess_bool , \g_yoin_article_bool ,
%    \g_yoin_dryrun_bool , \g_yoin_onlyflags_bool , \g_yoin_onlytags_bool }
% Booleans:
%    \begin{macrocode}
\bool_new:N \g_yoin_subprocess_bool
\bool_new:N \g_yoin_article_bool
\bool_new:N \g_yoin_dryrun_bool
\bool_new:N \g_yoin_onlyflags_bool
\bool_new:N \g_yoin_onlytags_bool
%    \end{macrocode}
% \end{macro}
% \begin{macro}{ \g_yoin_flags_seq , \g_yoin_tags_seq , \g_yoin_onlyflags_seq , \g_yoin_onlytags_seq }
% Sequences for flags, tags and their filtering:
%    \begin{macrocode}
\seq_new:N \g_yoin_flags_seq
\seq_new:N \g_yoin_tags_seq
\seq_new:N \g_yoin_onlyflags_seq
\seq_new:N \g_yoin_onlytags_seq
%    \end{macrocode}
% \end{macro}
% \begin{macro}{ \g_yoin_jobname_tl }
% We can modify what the package considers as the value of |\jobname|, here's a token list for that:
%    \begin{macrocode}
\tl_new:N \g_yoin_jobname_tl
\tl_gset_eq:NN \g_yoin_jobname_tl \c_job_name_tl
%    \end{macrocode}
% \end{macro}
% \begin{macro}{ msg: unknown-flag , msg: unknown-tag }
% Two messages, for unknown flags and unknown tags.
%    \begin{macrocode}
\msg_new:nnnn { yoin } { unknown-flag }
	{ The ~ flag ~ `#1' ~ is ~ unknown ~ to ~ `yoin'. }
	{ You ~ either ~ misspelled ~ it ~ or ~forgot ~ to ~ declare ~ it. }
%    \end{macrocode}
%    \begin{macrocode}
\msg_new:nnnn { yoin } { unknown-tag }
	{ The ~ tag ~ `#1' ~ is ~ unknown ~ to ~ `yoin'. }
	{ You ~ either ~ misspelled ~ it ~ or ~forgot ~ to ~ declare ~ it. }
%    \end{macrocode}
% \end{macro}
% \begin{macro}{ \yoin_if_tag_defined:n , \yoin_if_flag_defined:n }
% Conditionals for checking whether a tag/flag was defined.
%    \begin{macrocode}
\prg_new_protected_conditional:Nnn \yoin_if_tag_defined:n { T, F, TF } {
	\seq_if_in:NnTF \g_yoin_tags_seq { #1 } { \prg_return_true: } { \prg_return_false: }
}
%    \end{macrocode}
%    \begin{macrocode}
\prg_new_protected_conditional:Nnn \yoin_if_flag_defined:n { T, F, TF } {
	\seq_if_in:NnTF \g_yoin_flags_seq { #1 } { \prg_return_true: } { \prg_return_false: }
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{ \@@_error_if_tag_undefined:n , \@@_error_if_flag_undefined:n }
% Check whether a tag/flag is defined, if not, issue an error.
%    \begin{macrocode}
\cs_new_protected:Nn \@@_error_if_tag_undefined:n {
	\yoin_if_tag_defined:nF { #1 } { \msg_error:nnn { yoin } { unknown-tag } { #1 } }
}
%    \end{macrocode}
%    \begin{macrocode}
\cs_new_protected:Nn \@@_error_if_flag_undefined:n {
	\yoin_if_flag_defined:nF { #1 } { \msg_error:nnn { yoin } { unknown-flag } { #1 } }
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{ yoin / general }
% The keys themselves:
%    \begin{macrocode}
\keys_define:nn { yoin / general } {
%    \end{macrocode}
% Booleans:
%    \begin{macrocode}
	dryrun .bool_gset:N = \g_yoin_dryrun_bool,
	dryrun .initial:n = { false },
%    \end{macrocode}
%    \begin{macrocode}
	article .bool_gset:N = \g_yoin_article_bool,
	article .initial:n = { false },
%    \end{macrocode}
%    \begin{macrocode}
	subprocess .bool_gset:N = \g_yoin_subprocess_bool,
	subprocess .initial:n = { false },
%    \end{macrocode}
% Keys whose |clist| values are appended to a |seq|:
%    \begin{macrocode}
	defineflags .code:n = \yoin_seq_gappend_clist:Nn \g_yoin_flags_seq { #1 },
%    \end{macrocode}
%    \begin{macrocode}
	definetags .code:n = \yoin_seq_gappend_clist:Nn \g_yoin_tags_seq { #1 },
%    \end{macrocode}
% A |clist| key is stored in a |seq|, also, a corresponding |bool| is set true.
% (The point is, if |onlyflags|/|onlytags| is not ever set up, we want to know it since
% we treat it as if we use all flags/tags.)
%    \begin{macrocode}
	onlyflags .code:n =
		\seq_gset_from_clist:Nn \g_yoin_onlyflags_seq { #1 }
		\bool_gset_true:N \g_yoin_onlyflags_bool
		,
%    \end{macrocode}
%    \begin{macrocode}
	onlytags .code:n =
		\seq_gset_from_clist:Nn \g_yoin_onlytags_seq { #1 }
		\bool_gset_true:N \g_yoin_onlytags_bool
		,
%    \end{macrocode}
% A key whose value is stored in a token list.
%    \begin{macrocode}
	jobname .tl_gset:N = \g_yoin_jobname_tl,
%    \end{macrocode}
%    \begin{macrocode}
% A key that allows |\yoinMeta| to be called from within the package options.
%    \begin{macrocode}
	meta .code:n = \yoin_yoinmeta:n { #1 },
%    \end{macrocode}
%    \begin{macrocode}
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{ \ProcessKeysPackageOptions }
% Process key options given to the package.
% We \emph{do not want to process any options given to the class}.
% Whence |\ProcessKeysPackageOptions| and not |\ProcessKeysOptions|.
%    \begin{macrocode}
\ProcessKeysPackageOptions { yoin / general }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{ \yoin_setup:n , \yoinSetup }
% Allow keys to be set later. We define both a \LaTeX3 interface and an xparse UI wrapper.
%    \begin{macrocode}
\cs_new_protected:Nn \yoin_setup:n {
	\keys_set:nn { yoin / general } { #1 }
}
%    \end{macrocode}
%    \begin{macrocode}
\NewDocumentCommand \yoinSetup { R[]{} } {
	\yoin_setup:n { #1 }
}
%    \end{macrocode}
% \end{macro}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \section{yoinMeta macro --- adding issue's metadata}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% \begin{macro}{ \yoinMeta, \yoin_yoinmeta:n }
%    \begin{macrocode}
\prop_new:N \l_@@_yoinmeta_prop
\cs_new_protected:Nn \@@_yoinmeta_storekey:nn {
	\prop_put:Nnn \l_@@_yoinmeta_prop { #1 } { #2 }
}
\cs_new_protected:Nn \@@_yoinmeta_storekey:n {
	\prop_put:Nnn \l_@@_yoinmeta_prop { #1 } { }
}
\cs_new_protected:Nn \yoin_yoinmeta:n {
	\keyval_parse:NNn \@@_yoinmeta_storekey:n \@@_yoinmeta_storekey:nn { #1 }
}
\NewDocumentCommand \yoinMeta { R[]{} } {
	\yoin_yoinmeta:n { #1 }
}
%    \end{macrocode}
% \end{macro}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \section{yoinAdd macro --- adding articles to the issue}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% The key--value interface. In this case, we basically only store the keys for each article in a |prop|.
% First, an interface for setting the keys for the articles.
% |\yoin_yoinadd_prop:n| returns the name of the |prop| for the given article;
%  \emph{no check for existence is done at this place.}
% \begin{macro}{ \g_yoin_yoinadd_seq }
% A sequence for storing the list of the existing articles.
%    \begin{macrocode}
\seq_new:N \g_yoin_yoinadd_seq
%    \end{macrocode}
% \end{macro}
% \begin{macro}{ \yoin_yoinadd_prop:n , \yoin_yoinadd_prop:V , \yoin_yoinadd_prop_item:nn , \yoin_yoinadd_prop_item:Vn }
% |\yoin_yoinadd_prop:n| returns the name of the |prop| for the given article;
%  \emph{no check for existence is done at this place.}
% |\yoin_yoinadd_prop:nn| returns property |\#2| of article |\#1|, or |\q_no_value| if the property is not set.
%    \begin{macrocode}
\cs_new:Nn \yoin_yoinadd_prop:n {
	g_@@_article_#1_prop
}
\cs_generate_variant:Nn \yoin_yoinadd_prop:n { V }
%    \end{macrocode}
%    \begin{macrocode}
\cs_new:Nn \yoin_yoinadd_prop_item:nn {
	\prop_item:cn { \yoin_yoinadd_prop:n { #1 } } { #2 }
}
\cs_generate_variant:Nn \yoin_yoinadd_prop_item:nn { V }
%    \end{macrocode}
% \end{macro}
% For processing |\yoinAdd|, we first set up a |tl| to contain the name of the article, then create the |prop|,
%  and finally use |l3keys| to fill in the |prop|.
% Note that if an article is added twice, an error is issued, if the error is ignored, the article is not added but
%  the properties are set.
% \begin{macro}{ \l_@@_yoinadd_currentarticle_tl }
% A |tl| that stores the name of the article that is being processed by |\yoinAdd|.
%    \begin{macrocode}
\tl_new:N \l_@@_yoinadd_currentarticle_tl
%    \end{macrocode}
% \end{macro}
% \begin{macro}{ \@@_yoinadd_storekey:nn , \@@_yoinadd_storekey:n }
% Internal macro for storing a key in the prop. The one-parameter variant sets the value of the key empty.
%    \begin{macrocode}
\cs_new_protected:Nn \@@_yoinadd_storekey:nn {
	\prop_gput:cnn { \yoin_yoinadd_prop:V \l_@@_yoinadd_currentarticle_tl } { #1 } { #2 }
}
\cs_new_protected:Nn \@@_yoinadd_storekey:n {
	\prop_gput:cnn { \yoin_yoinadd_prop:V \l_@@_yoinadd_currentarticle_tl } { #1 } { }
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{ \yoin_yoinadd:nn , \yoinAdd }
% The macro |\yoinAdd| itself.
% We first set |\l_@@_yoinadd_currentarticle_tl|, then check whether the same article has not been processed before
%  (issuing an error in that case and finishing).
% Then, the article is added in |\g_yoin_yoinadd_seq|, the |prop| created,
% the article's name added in the |prop| with key |article| and the keys are set.
% If the article has a |.yoin| file in its sub-directory, the key--values in it is added to the |prop|.
% If the file does not exist, it means things are wrong (the article should first be set up,
%  before being added to its issue by |\yoinAdd|).
%    \begin{macrocode}
\cs_new_protected:Nn \yoin_yoinadd:nn {
	\tl_set:Nn \l_@@_yoinadd_currentarticle_tl { #1 }
	\seq_if_in:NnTF \g_yoin_yoinadd_seq { #1 } {
		\msg_error:nnn { yoin } { yoinadd-duplicatearticle } { #1 }
	} {
		\seq_gput_right:Nn \g_yoin_yoinadd_seq { #1 }
		\prop_new:c { \yoin_yoinadd_prop:n { #1 } }
		\clist_map_inline:nn { forceopenany, forceopenright, ignore } {
			\@@_yoinadd_storekey:nn { ##1 } { 0 }
		}
		\@@_yoinadd_storekey:nn { article } { #1 }
		\keys_set:nn { yoin / yoinadd } { #2 }
		\file_if_exist:nTF { #1 / #1 .yoin } {
			\yoin_keyval_parse_from_file:NNn
				\@@_yoinadd_storekey:n
				\@@_yoinadd_storekey:nn
				{ #1 / #1 .yoin }
		} {
			\msg_error:nnn { yoin } { yoinadd-dotyoinmissing } { #1 }
		}
	}
}
%    \end{macrocode}
%    \begin{macrocode}
\NewDocumentCommand \yoinAdd { m O{} } {
	\yoin_yoinadd:nn { #1 } { #2 }
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{ msg: yoinadd-duplicatearticle , msg: yoinadd-dotyoinmissing }
% The error messages: for adding a duplicate article and for adding an article with no |#1/#1.yoin| file.
%    \begin{macrocode}
\msg_new:nnn { yoin } { yoinadd-duplicatearticle }
	{ The ~ article ~ "#1" ~ has ~ been ~ already ~ processed ~ by ~ \token_to_str:N \yoinAdd ~.}
\msg_new:nnn { yoin } { yoinadd-dotyoinmissing }
	{ The ~ article ~ "#1" ~ has ~ no ~ file "#1/#1.yoin" ~ and ~ was ~ not ~ properly ~ set ~ up.}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{ yoin / yoinadd }
% The keys here are pretty simple; each defined key just stores its value in the |prop|.
% We recall that |\#1| is the key and |\#\#1| is the value.
%    \begin{macrocode}
\clist_map_inline:nn { textualkey } {
	\keys_define:nn { yoin / yoinadd } {
		#1 .code:n = \@@_yoinadd_storekey:nn { #1 } { ##1 },
	}
}
%    \end{macrocode}
% For boolean keys, we create a manual boolean parser.
%    \begin{macrocode}
\clist_map_inline:nn { forceopenany, forceopenright, ignore } {
	\keys_define:nn { yoin / yoinadd } {
		#1 .choice:,
		#1 / true .code:n = \@@_yoinadd_storekey:nn { #1 } { 1 },
		#1 / false .code:n = \@@_yoinadd_storekey:nn { #1 } { 0 },
		#1 / unknown .code:n = \msg_error:nnx { yoin } { boolean-values-only } { \l_keys_key_tl },
	}
}
%    \end{macrocode}
% However, for the |tag| key, we additionally check that the tag exists.
%    \begin{macrocode}
\keys_define:nn { yoin / yoinadd } {
	tag .code:n =
		\@@_error_if_tag_undefined:n { #1 }
		\@@_yoinadd_storekey:nn { tag } { #1 }
		,
}
%    \end{macrocode}
% \end{macro}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \section{Environment yoinshell}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% \begin{macro}{ \l_yoin_yoinshell_ignore_bool }
% A boolean for storing the |ignore| key's value.
%    \begin{macrocode}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{ yoin / yoinshell }
% Key--value interface to |yoinshell|.
%    \begin{macrocode}
\keys_define:nn { yoin / yoinshell } {
%    \end{macrocode}
% If |flag| is set and |onlyflags| is set but the flag is not amongst them, the whole |yoinshell| is ignored
%  (by setting the |ignore| key).
%    \begin{macrocode}
	flag .code:n =
		\@@_error_if_flag_undefined:n { #1 }
		\bool_if:NT \g_yoin_onlyflags_bool {
			\seq_if_in:NnF \g_yoin_onlyflags_seq { #1 } {
				\keys_set:nn { yoin / yoinshell } {
					ignore = true
				}
			}
		}
		,
%    \end{macrocode}
% The |ignore| key sets a boolean
%    \begin{macrocode}
	ignore .bool_set:N = \l_yoin_yoinshell_ignore_bool,
	ignore .initial:n = { false },
%    \end{macrocode}
%    \begin{macrocode}
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{ shellesc.sty , \ShellEscape , \__yoin_yoinshell_shellescape:n }
% A reasonable shell escape that should work in both |pdflatex| and |lualatex| in \TeX\,Live 2016.
%    \begin{macrocode}
\file_if_exist:nTF { shellesc.sty } {
	\RequirePackage { shellesc }
} {
	\def \ShellEscape #1 { \immediate \write 18 { #1 } }
}
\cs_new_protected:Nn \@@_yoinshell_shellescape:n {
	\ShellEscape { #1 }
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{ \@@_yoinshell_begin:n , \@@_yoinshell_end: , {yoinshell} }
% Environment |yoinshell| (one key--value argument).
% We perform some local definitions that should stay local, so we put everything in a group.
% The keys are set. Then we define the macros --- ``shell commands''.
% If |ignore| is set or if |subprocess| is passed to the package, these macros are declared to do nothing,
%  otherwise they are simply wrappers to the \LaTeX3 counterparts.
%    \begin{macrocode}
\cs_new_protected:Nn \@@_yoinshell_begin:n {
	\group_begin:
	\keys_set:nn { yoin / yoinshell } { #1 }
	\bool_if:NT \g_yoin_subprocess_bool {
		\bool_set_true:N \l_yoin_yoinshell_ignore_bool
	}
	\bool_if:NTF \l_yoin_yoinshell_ignore_bool {
		\DeclareDocumentCommand \RunForEach { O{} m } { }
		\DeclareDocumentCommand \Run { O{} m } { }
		\DeclareDocumentCommand \WriteMeta { O{} } { }
	} {
		\DeclareDocumentCommand \RunForEach { O{} m } { \yoin_yoinshell_runforeach:nn { ##1 } { ##2 } }
		\DeclareDocumentCommand \Run { O{} m } { \yoin_yoinshell_run:nn { ##1 } { ##2 } }
		\DeclareDocumentCommand \WriteMeta { O{} } { \yoin_yoinshell_writemeta:n { ##1 } }
		\yoin_yoinshell_writemeta:n { }
	}
}
%    \end{macrocode}
%    \begin{macrocode}
\cs_new_protected:Nn \@@_yoinshell_end: {
	\group_end:
}
%    \end{macrocode}
%    \begin{macrocode}
\NewDocumentEnvironment { yoinshell } { O{} } {
	\@@_yoinshell_begin:n { #1 }
} {
	\@@_yoinshell_end:
}
%    \end{macrocode}
% \end{macro}
%
% \subsection{RunForEach}
%
% \begin{macro}{ \l_@@_yoinshell_runforarticle_tag_tl , \l_@@_yoinshell_runforeach_onlytag_tl }
% First, two |tl|s that will store tags: One for the tag of the article,
%  one that could be passed to |\RunForEach| that is initially set to |\q_no_value|.
%    \begin{macrocode}
\tl_new:N \l_@@_yoinshell_runforarticle_tag_tl
\tl_new:N \l_@@_yoinshell_runforeach_onlytag_tl
\tl_set:Nn \l_@@_yoinshell_runforeach_onlytag_tl { \q_no_value }
%    \end{macrocode}
% \end{macro}
% \begin{macro}{ yoin / runforeach }
% So far, the only key--val passable to |\RunForEach| is |onlytag|,
%  which tests for the tag to be declared and passes it to |\l_@@_yoinshell_runforeach_onlytag_tl|.
%    \begin{macrocode}
\keys_define:nn { yoin / runforeach } {	
	onlytag .code:n =
		\@@_error_if_tag_undefined:n { #1 }
		\tl_set:Nn \l_@@_yoinshell_runforeach_onlytag_tl { #1 }
		,	
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{ \@@_yoinshell_runforarticle_keyfromprop:nnN }
% This macro lets |#3| to the value of property |#2| of article |#1|.
% It makes it an empty definition if the property is unset.
%    \begin{macrocode}
\tl_new:N \l_@@_yoinshell_runforarticle_tmpa_tl
\cs_new_protected:Nn \@@_yoinshell_runforarticle_keyfromprop:nnN {
	\prop_get:cnN { \yoin_yoinadd_prop:n { #1 } } { #2 } \l_@@_yoinshell_runforarticle_tmpa_tl
	\quark_if_no_value:NTF \l_@@_yoinshell_runforarticle_tmpa_tl {
		\def #3 {}
	} {
		\let #3 \l_@@_yoinshell_runforarticle_tmpa_tl
	}
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{ \@@_yoinshell_runforeach:nn }
% |\RunForEach| itself just sets the keys (in a group to make things local)
%  and then calls |\@@_yoinshell_runforarticle:nn| on each article.
%    \begin{macrocode}
\cs_new_protected:Nn \yoin_yoinshell_runforeach:nn {
	\group_begin:
	\keys_set:nn { yoin / runforeach } { #1 }
	\seq_map_inline:Nn \g_yoin_yoinadd_seq { \@@_yoinshell_runforarticle:nn { ##1 } { #2 } }
	\group_end:
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{ \@@_yoinshell_runforarticle:nn }
% If the tag passed to |onlytag| of |\RunForEach| is identical to the tag of the article
%  or if any of them is not set, we do what should be done, otherwise nothing is done (the tags do not match).
% We only extract the |prop| to publically available macros like |\Article|, |\Jobname| etc.\@
% (in a group to make this local), and then run the command in shell escape.
%    \begin{macrocode}
\cs_new_protected:Nn \@@_yoinshell_runforarticle:nn {
	\prop_get:cnN { \yoin_yoinadd_prop:n { #1 } } { tag } \l_@@_yoinshell_runforarticle_tag_tl
	\bool_if:nT {
		\quark_if_no_value_p:N \l_@@_yoinshell_runforarticle_tag_tl
		||
		\quark_if_no_value_p:N \l_@@_yoinshell_runforeach_onlytag_tl
		||
		\tl_if_eq_p:NN \l_@@_yoinshell_runforeach_onlytag_tl \l_@@_yoinshell_runforarticle_tag_tl
	}{
		\group_begin:
		\@@_yoinshell_runforarticle_keyfromprop:nnN { #1 } { article } \Article
		\@@_yoinshell_runforarticle_keyfromprop:nnN { #1 } { jobname } \Jobname
		\@@_yoinshell_runforarticle_keyfromprop:nnN { #1 } { firstpage } \FirstPage
		\@@_yoinshell_shellescape:n { #2 }
		\group_end:
	}
}
%    \end{macrocode}
% \end{macro}
%
% \subsection{Run}
%
% \begin{macro}{ \@@_yoinshell_run:nn }
%    \begin{macrocode}
\cs_new_protected:Nn \yoin_yoinshell_run:nn {
	\group_begin:
	\keys_set:nn { yoin / run } { #1 }
	\let \Jobname \c_job_name_tl
	\@@_yoinshell_shellescape:n { #2 }
	\group_end:
}
%    \end{macrocode}
% \end{macro}
%
% \subsection{WriteMeta}
%
% \begin{macro}{ \@@_yoinshell_writemeta:n }
%    \begin{macrocode}
\iow_new:N \g_@@_yoinshell_iow
\cs_new_protected:Nn \yoin_yoinshell_writemeta:n {
	\group_begin:
	\yoin_yoinmeta:n { #1 }
	\iow_open:Nn \g_@@_yoinshell_iow { \g_yoin_jobname_tl .yoin }
	\prop_map_inline:Nn \l_@@_yoinmeta_prop {
		\iow_now:Nn \g_@@_yoinshell_iow { meta-##1 ~ = ~ ##2, }
	}
	\iow_close:N \g_@@_yoinshell_iow
	\group_end:
}
%    \end{macrocode}
% \end{macro}
%
%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \section{macro yoinForEach}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% \begin{macro}{ \l_@@_yoinforeach_article_tag_tl , \l_@@_yoinforeach_onlytag_tl }
% First, two |tl|s that will store tags: One for the tag of the article,
%  one that could be passed to |\yoinForEach| that is initially set to |\q_no_value|.
%    \begin{macrocode}
\tl_new:N \l_@@_yoinforeach_article_tag_tl
\tl_new:N \l_@@_yoinforeach_onlytag_tl
\tl_set:Nn \l_@@_yoinforeach_onlytag_tl { \q_no_value }
%    \end{macrocode}
% \end{macro}
% \begin{macro}{ yoin / yoinforeach }
% So far, the only key--val passable to |\yoinForEach| is |onlytag|,
%  which tests for the tag to be declared and passes it to |\l_@@_yoinforeach_onlytag_tl|.
%    \begin{macrocode}
\keys_define:nn { yoin / yoinforeach } {	
	onlytag .code:n =
		\@@_error_if_tag_undefined:n { #1 }
		\tl_set:Nn \l_@@_yoinforeach_onlytag_tl { #1 }
		,	
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{ \@@_yoinforeach_article_keyfromprop:nnN }
% This macro lets |#3| to the value of property |#2| of article |#1|.
% It makes it an empty definition if the property is unset.
%    \begin{macrocode}
\tl_new:N \l_@@_yoinforeach_tmpa_tl
\cs_new_protected:Nn \@@_yoinforeach_article_keyfromprop:nnN {
	\prop_get:cnN { \yoin_yoinadd_prop:n { #1 } } { #2 } \l_@@_yoinforeach_tmpa_tl
	\quark_if_no_value:NTF \l_@@_yoinforeach_article_tmpa_tl {
		\def #3 {}
	} {
		\let #3 \l_@@_yoinforeach_tmpa_tl
	}
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{ \@@_yoinforeach_article_metaitem:nnN }
% This macro lets |#3| to the value of property |#2| of article |#1|.
% It makes it an empty definition if the property is unset.
%    \begin{macrocode}
\cs_new:Nn \@@_yoinforeach_article_metaitem:nn {
	\yoin_yoinadd_prop_item:nn { #1 } { article-#2 }
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{ \@@_yoinforeach:nn }
% |\yoinForEach| itself just sets the keys (in a group to make things local)
%  and then calls |\@@_yoinforeach_article:nn| on each article.
%    \begin{macrocode}
\cs_new_protected:Nn \yoin_yoinforeach:nn {
	\group_begin:
	\keys_set:nn { yoin / yoinforeach } { #1 }
	\seq_map_inline:Nn \g_yoin_yoinadd_seq { \@@_yoinforeach_article:nn { ##1 } { #2 } }
	\group_end:
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{ \@@_yoinshell_runforarticle:nn }
% If the tag passed to |onlytag| of |\RunForEach| is identical to the tag of the article
%  or if any of them is not set, we do what should be done, otherwise nothing is done (the tags do not match).
% We only extract the |prop| to publically available macros like |\Article|, |\Jobname| etc.\@
% (in a group to make this local), and then run the command in shell escape.
%    \begin{macrocode}
\cs_new_protected:Nn \@@_yoinforeach_article:nn {
	\prop_get:cnN { \yoin_yoinadd_prop:n { #1 } } { tag } \l_@@_yoinforeach_article_tag_tl
	\bool_if:nT {
		\quark_if_no_value_p:N \l_@@_yoinforeach_article_tag_tl
		||
		\quark_if_no_value_p:N \l_@@_yoinforeach_onlytag_tl
		||
		\tl_if_eq_p:NN \l_@@_yoinforeach_onlytag_tl \l_@@_yoinforeach_article_tag_tl
	}
	{
		\group_begin:
		\DeclareDocumentCommand \Meta { m } { \@@_yoinforeach_article_metaitem:nn { #1 } { ##1 } }
		\@@_yoinforeach_article_keyfromprop:nnN { #1 } { article } \Article
		\@@_yoinforeach_article_keyfromprop:nnN { #1 } { jobname } \Jobname
		\@@_yoinforeach_article_keyfromprop:nnN { #1 } { firstpage } \FirstPage
		#2
		\group_end:
	}
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{ \yoinForEach }
% One optional key--val argument, one mandatory argument --- the text to be typeset.
%    \begin{macrocode}
\NewDocumentCommand \yoinForEach { O{} +m } {
	\yoin_yoinforeach:nn { #1 } { #2 }
}
%    \end{macrocode}
% \end{macro}
%
%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \section{Article setting stuff (undocumented)}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Information to be stored in an auxiliary file.
%    \begin{macrocode}
\cs_new_protected:Nn \@@_article_write_keyval:nn {
	\iow_now:Nn \g_@@_article_dotyoin_iow { #1 ~ = ~ #2 , }
}
\cs_generate_variant:Nn \@@_article_write_keyval:nn { nx, nV }

\cs_new_protected:Nn \yoin_article_write_meta:nn {
	\@@_article_write_keyval:nn { article-#1 } { #2 }
}

\cs_new_protected:Nn \yoin_article_writekeys: {
	\@@_article_write_keyval:nV { jobname } \c_job_name_tl
	\@@_article_write_keyval:nx { totpages } { \ztotpages }
	\@@_article_write_keyval:nV { currdir } \l_yoin_article_currdir_tl
	\@@_article_write_keyval:nx { firstpage } { \int_use:N \l_yoin_article_firstpage_int }
}

\prop_new:N \l_@@_article_readkeys_prop

\cs_new_protected:Nn \yoin_article_set_readkey:nn {
	\prop_put:Nnn \l_@@_article_readkeys_prop { #1 } { #2 }
}
\cs_generate_variant:Nn \yoin_article_set_readkey:nn { Vn }

\int_new:N \l_yoin_article_firstpage_int
\int_set:Nn \l_yoin_article_firstpage_int { 1 }

\keys_define:nn { yoin / toarticle } {
	firstpage .code:n =
		\int_set:Nn \l_yoin_article_firstpage_int { #1 }
		\yoin_article_set_readkey:nn { firstpage } { #1 }
		,

	parent .code:n =
		\file_if_exist:nT { ../ #1 .yoin } {
			\yoin_keys_set_from_file:nn { yoin / toarticle } { ../ #1 .yoin }
		}
		\yoin_article_set_readkey:nn { parent } { #1 }
		,
	
	unknown .code:n =
		\yoin_article_set_readkey:Vn \l_keys_key_tl { #1 }
		,
}

\bool_new:N \g_@@_article_readkeys_bool
\bool_gset_true:N \g_@@_article_readkeys_bool

\cs_new_protected:Nn \yoin_article_readkeys: {
	\bool_if:NT \g_@@_article_readkeys_bool {
		\file_if_exist:nT { ../ \l_yoin_article_currdir_tl .yoin1 } {
			\yoin_keys_set_from_file:nn { yoin / toarticle } { ../ \l_yoin_article_currdir_tl .yoin1 }
		}
	}
	\bool_gset_false:N \g_@@_article_readkeys_bool
}

\cs_new:Nn \yoin_article_meta:n {
	\prop_item:Nn \l_@@_article_readkeys_prop { meta-#1 }
}

\cs_new:Nn \yoin_article_meta_gset_tl_default:Nnn {
	\prop_get:NnNF \l_@@_article_readkeys_prop { meta-#2 } #1 {
		\tl_set:Nn #1 { #3 }
	}
}

\NewDocumentCommand \yoinArticleMeta { m } {
	\yoin_article_meta:n { #1 }
}

\tl_new:N \l_@@_article_tmpa_tl
\seq_new:N \l_@@_article_tmpa_seq
\tl_new:N \l_yoin_article_currdir_tl
\cs_generate_variant:Nn \regex_extract_once:nnN { nV }
\cs_new_protected:Nn \yoin_article_getcurrdir:N {
	\tl_set:Nx \l_@@_article_tmpa_tl { \currfileabsdir }
	\regex_extract_once:nVN { /([^/]+)/\Z } \l_@@_article_tmpa_tl \l_@@_article_tmpa_seq
	\seq_get_right:NN \l_@@_article_tmpa_seq #1
}

\iow_new:N \g_@@_article_dotyoin_iow
\bool_if:NT \g_yoin_article_bool {
	\yoin_article_getcurrdir:N \l_yoin_article_currdir_tl
	\iow_open:Nn \g_@@_article_dotyoin_iow { \l_yoin_article_currdir_tl .yoin }
	\yoin_article_readkeys:
	\AtBeginDocument {
		\setcounter { page } { \l_yoin_article_firstpage_int }
		\yoin_article_writekeys:
	}
}
%    \end{macrocode}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \section{yoinProcess (undocumented)}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% \begin{macro}{ msg: forceopenanyright }
% Error message for an article having both |forceopenany| and |forceopenright| set.
%    \begin{macrocode}
\msg_new:nnn { yoin } { forceopenanyright }
	{ The ~ article ~ '#1' ~ has ~ both ~ 'forceopenany' ~ and ~ 'forceopenright' ~ keys ~ set. }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{ \yoin_yoinprocess:n }
% The key macro of the package, to some sense. It takes care of the page numbering of the articles,
% proper placement of stuff in twoside environment, etc.
%    \begin{macrocode}
\cs_new_protected:Nn \yoin_yoinprocess:n {
%    \end{macrocode}
% Set the appropriate keys (this may be changed later and moved to |yoin/general| keys.
%    \begin{macrocode}
	\keys_set:nn { yoin / yoinprocess } { #1 }
%    \end{macrocode}
% Finish the current page if it's started.
%    \begin{macrocode}
	\clearpage
%    \end{macrocode}
% Go to the right page number. This depends on two parameters, |cleardoublepage| and |setpagenumber|,
%  the dependence is explained in each of the 4 cases.
%    \begin{macrocode}
	\bool_if:NTF \l_@@_yoinprocess_cleardoublepage_bool {
		\bool_if:NTF \l_@@_yoinprocess_setpagenumber_bool {
%    \end{macrocode}
% Case |cleardoublepage|, |setpagenumber|.
% In this case, an empty page is added as necessary to keep the parity of page numbers.
% For instance, if |setpagenumber=110| and last page number is |4|, an empty page is added
%  so that there are no two consecutive even pages.
% The check is on the parity of the sum of the two numbers.
% The macro |\__yoin_yoinprocess_clearonepage:| uses the code of
%  \LaTeXe's |\cleardoublepage| for creating the necessary empty page.
%    \begin{macrocode}
			\int_if_odd:nT { \value { page } + \l_@@_yoinprocess_setpagenumber_int } {
				\@@_yoinprocess_clearonepage:
			}
			\setcounter { page } { \int_use:N \l_@@_yoinprocess_setpagenumber_int }
		} {
%    \end{macrocode}
% Case |cleardoublepage|, |nosetpagenumber|.
% We simply do a cleardoublepage.
% Note that |\__yoin_yoinprocess_cleardoublepage:| modifies the value of |\g_@@_page_int|
%  in a useless way at this place, but we will override the value anyway.
%    \begin{macrocode}
			\@@_yoinprocess_cleardoublepage:
		}
	} {
%    \end{macrocode}
% Case |nocleardoublepage|, |setpagenumber|.
% We simply set the page number.
%    \begin{macrocode}
		\bool_if:NTF \l_@@_yoinprocess_setpagenumber_bool {
			\setcounter { page } { \int_use:N \l_@@_yoinprocess_setpagenumber_int }
		} {
%    \end{macrocode}
% Case |nocleardoublepage|, |nosetpagenumber|.
% No adjustment is needed in this case.
%    \begin{macrocode}
			\prg_do_nothing:
		}
	}
%    \end{macrocode}
% Here, the loop through the articles starts.
% First, set the internal counter for the page number;
%  this is necessary because if the output of the process is suppressed by the key |output=false|,
%  we need to keep track of the page number manually.
%    \begin{macrocode}
	\int_gset:Nn \g_@@_page_int { \value { page } }
	\seq_map_inline:Nn \g_yoin_yoinadd_seq {
%    \end{macrocode}
% Handing of even/odd/pages.
% First, issue an error if both |addarticle/forceopenany| and |addarticle/forceopenright| are set.
%    \begin{macrocode}
		\bool_if:nT {
			\int_compare_p:nNn {
				\yoin_yoinadd_prop_item:nn { ##1 } { forceopenany }
				+ \yoin_yoinadd_prop_item:nn { ##1 } { forceopenright }
			} = { 2 }
		} {
			\msg_error:nnn { yoin } { forceopenanyright } { ##1 }
		}
%    \end{macrocode}
% Then, we call |cleardoublepage| (our internal variant) if:
%  either |forceopenright| is true;
%  or |openright| is true and |forceopenany| is false.
%    \begin{macrocode}
		\bool_if:nT {
			\int_compare_p:nNn { \yoin_yoinadd_prop_item:nn { ##1 } { forceopenright } } = { 1 }
			|| (
				\l_@@_yoinprocess_openright_bool
				&&
				\int_compare_p:nNn { \yoin_yoinadd_prop_item:nn { ##1 } { forceopenany } } = { 0 }
			)
		} {
			\@@_yoinprocess_cleardoublepage:
		}
%    \end{macrocode}
% If |output| is true, we use |\includepdf| to include the PDF of the article.
%    \begin{macrocode}
		\bool_if:NT \l_@@_yoinprocess_output_bool { 
			\includepdf [ pages = - ] { ##1 / \yoin_yoinadd_prop_item:nn { ##1 } { jobname } .pdf }
		}
%    \end{macrocode}
% Into file |./<articlename>.yoin1| we save the data to be transferred to the article:
%  the first page number (possibly |1| if |alwayspageone| key is set) and the name of the this document.
%    \begin{macrocode}
		\iow_open:Nn \g_@@_yoinprocess_iow { ##1 .yoin1 }
		\bool_if:NTF \l_@@_yoinprocess_alwayspageone_bool { 
			\iow_now:Nx \g_@@_yoinprocess_iow { firstpage ~ = ~ 1 , }
		} {
			\iow_now:Nx \g_@@_yoinprocess_iow { firstpage ~ = ~ \int_use:N \g_@@_page_int , }
		}
		\iow_now:Nx \g_@@_yoinprocess_iow { parent ~ = ~ \jobname , }
		\iow_close:N \g_@@_yoinprocess_iow
%    \end{macrocode}
% Update our internal page counter.
%    \begin{macrocode}
		\int_gadd:Nn \g_@@_page_int { \yoin_yoinadd_prop_item:nn { ##1 } { totpages } }
	}
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{ \yoinProcess }
% Public wrapper around the \LaTeX3 version.
%    \begin{macrocode}
\DeclareDocumentCommand \yoinProcess { O{} } { \yoin_yoinprocess:n { #1 } }
%    \end{macrocode}
% \end{macro}
%
%    \begin{macrocode}

\int_new:N \g_@@_page_int
\iow_new:N \g_@@_yoinprocess_iow

\cs_new_protected:Nn \@@_yoinprocess_cleardoublepage: {
	\bool_if:NT \l_@@_yoinprocess_output_bool { \cleardoublepage }
	\int_if_even:nT { \g_@@_page_int } { \int_gincr:N \g_@@_page_int }
}

\cs_new_protected:Nn \@@_yoinprocess_clearonepage: {
	\bool_if:NT \l_@@_yoinprocess_output_bool {
		\hbox {}\newpage \if@twocolumn \hbox {}\newpage \fi
	}
	\int_gincr:N \g_@@_page_int
}

\bool_new:N \l_@@_yoinprocess_cleardoublepage_bool
\bool_new:N \l_@@_yoinprocess_output_bool
\bool_new:N \l_@@_yoinprocess_openright_bool
\bool_new:N \l_@@_yoinprocess_alwayspageone_bool
\bool_new:N \l_@@_yoinprocess_setpagenumber_bool
\int_new:N \l_@@_yoinprocess_setpagenumber_int
\keys_define:nn { yoin / yoinprocess } {

	cleardoublepage .bool_set:N = \l_@@_yoinprocess_cleardoublepage_bool ,
	cleardoublepage .initial:n = { false },

	output .bool_set:N = \l_@@_yoinprocess_output_bool ,
	output .initial:n = { true },

	openright .bool_set:N = \l_@@_yoinprocess_openright_bool ,
	openany .bool_set_inverse:N = \l_@@_yoinprocess_openright_bool ,
	openright .initial:n = { false },

	setpagenumber .code:n =
		\str_if_eq:nnTF { #1 } { false } {
			\bool_set_false:N \l_@@_yoinprocess_setpagenumber_bool
		} {
			\bool_set_true:N \l_@@_yoinprocess_setpagenumber_bool
			\int_set:Nn \l_@@_yoinprocess_setpagenumber_int { #1 }
		}
		,
	setpagenumber .initial:n = { false },
	
	alwayspageone .bool_set:N = \l_@@_yoinprocess_alwayspageone_bool ,
	alwayspageone .initial:n = { false },

}

%    \end{macrocode}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \section{Experimental}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% \begin{macro}{\bla}
%    \begin{macrocode}
\cs_new:Nn \yoin_blabla: {
	Blabla
}

%    \end{macrocode}
% \end{macro}
%
%    \begin{macrocode}
%</package>
%    \end{macrocode}
%
% \Finale