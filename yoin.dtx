% \iffalse meta-comment
%!TeX program = T_do_dtx
% 
% This part is not going to appear anywhere so is good for 'header'
% information.
%
%% These lines, starting with two "%", will be extracted so can be used
%% to copy some kind of header into target (.sty) files: the team .dtx
%% use this to dump the copyright header from the meta-comment block into
%% the output.
%
%<*driver>
\documentclass{l3doc}

\usepackage[vmargin=1in,hmargin={2in,1in},a4paper,landscape]{geometry}
\usepackage{lmodern,anttor}
\usepackage{xcolor}

\newcommand\T[1]{{\let\\\textbackslash\texttt{#1}}}
\newcommand\p[1]{\texttt{\##1}}

\DisableCrossrefs
\CodelineNumbered
\def\theCodelineNo{{\color{black}\normalfont\fontseries{sb}\selectfont\footnotesize\arabic{CodelineNo}}}
\def\MacroFont{\ttfamily\color{blue}}

% Whatever packages here
%
% Might include
% \usepackage{\jobname}
%
% Very handy is
% \usepackage[numbered]{hypdoc} % hyperref for l3doc
%
% You might want the following
%\EnableCrossrefs
%\CodelineIndex
%\RecordChanges
\begin{document}
  \DocInput{\jobname.dtx}
\end{document}
%</driver>
% \fi
%
% ^^A Comments in the documentation part start ^^A
%
% ^^A If you use the extracted package itself you can do
% \GetFileInfo{\jobname.sty}
% ^^A and define \filedate, etc.
%
% ^^A Meta data for the package
% \title{\pkg{mypkg}\thanks{^^A
%   This file describes version \fileversion, last revised \filedate.^^A
% }}
% \author{^^A
%   Tom Hejda\thanks{E-mail: tohecz@gmail.com}^^A
% }
% \date{Released \filedate}
%
% \section{User documentation}
%
% User documentation would appear here.
%
% ^^A This will appear at the end of the PDF, which might or might not include
% ^^A the typeset code
% \StopEventually{^^A
%   \PrintChanges
%   \PrintIndex
% }
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \section{Package header}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% We load the required packages needed for \LaTeX3, and the package header.
%
% \begin{macrocode}
%<*package>
%<@@=yoin>
\RequirePackage{expl3,l3keys2e,l3regex,xparse}
\RequirePackage{zref-totpages}
\RequirePackage[abspath]{currfile}
\ProvidesExplPackage{yoin}{2016/02/28}{v0.0.1}{Joining articles into issues}
%    \end{macrocode}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \section{General macros}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%    \begin{macro}{\yoin_seq_gappend_clist:Nn}
%    Globally append \T{clist} \p2 to \T{seq} \p1.
%    \begin{macrocode}
\cs_new_protected:Nn \yoin_seq_gappend_clist:Nn {
	\seq_set_from_clist:Nn \l_@@_tmpa_seq { #2 }
	\seq_gconcat:NNN #1 #1 \l_@@_tmpa_seq
}
%    \end{macrocode}
%    \end{macro}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \section{Key--value interface for the package setup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% First, we define the variables to store the keys.
%    \begin{macrocode}
\bool_new:N \g_yoin_subprocess_bool
\bool_new:N \g_yoin_article_bool
\bool_new:N \g_yoin_dryrun_bool
\bool_new:N \g_yoin_onlyflags_bool
\bool_new:N \g_yoin_onlytags_bool
%    \end{macrocode}
%    \begin{macrocode}
\seq_new:N \g_yoin_flags_seq
\seq_new:N \g_yoin_tags_seq
\seq_new:N \g_yoin_onlyflags_seq
\seq_new:N \g_yoin_onlytags_seq
%    \end{macrocode}
%    \begin{macrocode}
\tl_new:N \g_yoin_parent_tl
%    \end{macrocode}
%    \begin{macrocode}
\msg_new:nnnn { yoin } { unknown-flag }
	{ The ~ flag ~ `#1' ~ is ~ unknown ~ to ~ `yoin'. }
	{ You ~ either ~ misspelled ~ it ~ or ~forgot ~ to ~ declare ~ it. }
%    \end{macrocode}
%    \begin{macrocode}
\msg_new:nnnn { yoin } { unknown-tag }
	{ The ~ tag ~ `#1' ~ is ~ unknown ~ to ~ `yoin'. }
	{ You ~ either ~ misspelled ~ it ~ or ~forgot ~ to ~ declare ~ it. }
%    \end{macrocode}
% The keys themselves:
%    \begin{macrocode}
\keys_define:nn { yoin / general } {
%    \end{macrocode}
% Booleans:
%    \begin{macrocode}
	dryrun .bool_gset:N = \g_yoin_dryrun_bool,
	dryrun .initial:n = { false },
%    \end{macrocode}
%    \begin{macrocode}
	article .bool_gset:N = \g_yoin_article_bool,
	article .initial:n = { false },
%    \end{macrocode}
%    \begin{macrocode}
	subprocess .bool_gset:N = \g_yoin_subprocess_bool,
	subprocess .initial:n = { false },
%    \end{macrocode}
% Keys whose \T{clist} values are appended to a \T{seq}:
%    \begin{macrocode}
	defineflags .code:n = \yoin_seq_gappend_clist:Nn \g_yoin_flags_seq { #1 },
%    \end{macrocode}
%    \begin{macrocode}
	definetags .code:n = \yoin_seq_gappend_clist:Nn \g_yoin_tags_seq { #1 },
%    \end{macrocode}
% A \T{clist} key is stored in a \T{seq}, also, a corresponding \T{bool} is set true:
%    \begin{macrocode}
	onlyflags .code:n =
		\seq_gset_from_clist:Nn \g_yoin_onlyflags_seq { #1 }
		\bool_gset_true:N \g_yoin_onlyflags_bool
		,
%    \end{macrocode}
%    \begin{macrocode}
	onlytags .code:n =
		\seq_gset_from_clist:Nn \g_yoin_onlytags_seq { #1 }
		\bool_gset_true:N \g_yoin_onlytags_bool
		,
%    \end{macrocode}
% Key with a simple \T{tl} value (goes together with \T{article}):
%    \begin{macrocode}
	parent .tl_gset:N = \g_yoin_parent_tl
%    \end{macrocode}
%    \begin{macrocode}
}
%    \end{macrocode}
%
% Process key options given to the package.
% We \emph{do not want to process any options given to the class}.
% Whence \T{\\ProcessKeysPackageOptions} and not \T{\\ProcessKeysOptions}.
%    \begin{macrocode}
\ProcessKeysPackageOptions { yoin / general }
%    \end{macrocode}
%
% Allow keys to be set later. We define both a \LaTeX3 interface and an xparse UI wrapper.
%    \begin{macrocode}
\cs_new_protected:Nn \yoin_setup:n {
	\keys_set:nn { yoin / general } { #1 }
}
%    \end{macrocode}
%    \begin{macrocode}
\NewDocumentCommand \yoinSetup { R[]{} } {
	\yoin_setup:n { #1 }
}
%    \end{macrocode}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \section{\T{\\yoinAdd} macro --- adding articles to the issue}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% The key--value interface. In this case, we basically only store the keys for each article in a \T{prop}.
% First, an interface for setting the keys for the articles.
% \T{\\g_yoin_articles_seq} stores the list of the existing articles.
% \T{\\yoin_article_prop:n} returns the name of the \T{prop} for the given article;
%  \emph{no check for existence is done at this place.}
%    \begin{macrocode}
\seq_new:N \g_yoin_articles_seq
%    \end{macrocode}
%    \begin{macrocode}
\cs_new:Nn \yoin_article_prop:n {
	g_@@_article_#1_prop
}
\cs_generate_variant:Nn \yoin_article_prop:n { V }
%    \end{macrocode}
% For processing \T{\\yoinAdd}, we first set up a \T{tl} to contain the name of the article, then create the \T{prop},
%  and finally use \T{l3keys} to fill in the \T{prop}.
% Note that if an article is added twice, an error is issued, if the error is ignored, the article is not added but
%  the properties are set.
%    \begin{macrocode}
\tl_new:N \l_@@_yoinadd_currentarticle_tl
%    \end{macrocode}
%    \begin{macrocode}
\cs_new_protected:Nn \@@_yoinadd_storekey:nn {
	\prop_gput:cnn { \yoin_article_prop:V \l_@@_yoinadd_currentarticle_tl } { #1 } { #2 }
}
%    \end{macrocode}
%    \begin{macrocode}
\cs_new_protected:Nn \yoin_yoinadd:nn {
	\seq_if_in:NnTF \g_yoin_articles_seq { #1 } {
		\msg_error:nnn { yoin } { yoinadd / duplicatearticle } { #1 }
	} {
		\seq_gput_right:Nn \g_yoin_articles_seq { #1 }
		\prop_new:c { \yoin_article_prop:n { #1 } }
	}
	\tl_set:Nn \l_@@_yoinadd_currentarticle_tl { #1 }
	\keys_set:nn { yoin / yoinadd } { #2 }
}
%    \end{macrocode}
%    \begin{macrocode}
\NewDocumentCommand \yoinAdd { m O{} } {
	\yoin_yoinadd:nn { #1 } { #2 }
}
%    \end{macrocode}
% The error message for adding a duplicate article.
%    \begin{macrocode}
\msg_new:nnn { yoin } { yoinadd / duplicatearticle }
	{ The ~ article ~ "#1" ~ has ~ been ~ already ~ processed ~ by ~ \token_to_str:N \yoinAdd ~.}
%    \end{macrocode}
% The keys here are pretty simple; each defined key just stores its value in the \T{prop}.
% We recall that \T{\#1} is the key and \T{\#\#1} is the value.
%    \begin{macrocode}
\clist_map_inline:nn { forceopenany, forceopenright, ignore } {
	\keys_define:nn { yoin / yoinadd } {
		#1 .code:n = \@@_yoinadd_storekey:nn { #1 } { ##1 },
	}
}
%    \end{macrocode}
% However, for the \T{tag} key, we additionally check that the tag exists.
%    \begin{macrocode}
\keys_define:nn { yoin / yoinadd } {
	tag .code:n =
		\@@_error_if_tag_undefined:n { #1 }
		\@@_yoinadd_storekey:nn { tag } { #1 }
		,
}
%    \end{macrocode}
% ^^A    \begin{macrocode}
% ^^A    \end{macrocode}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \section{Conditionals for checking the existence of tags and flags}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%    \begin{macrocode}
\prg_new_protected_conditional:Nnn \yoin_if_tag_defined:n { T, F, TF } {
	\seq_if_in:NnTF \g_yoin_tags_seq { #1 } { \prg_return_true: } { \prg_return_false: }
}
\prg_new_protected_conditional:Nnn \yoin_if_flag_defined:n { T, F, TF } {
	\seq_if_in:NnTF \g_yoin_flags_seq { #1 } { \prg_return_true: } { \prg_return_false: }
}
\cs_new_protected:Nn \@@_error_if_tag_undefined:n {
	\yoin_if_tag_defined:nF { #1 } { \msg_error:nnn { yoin } { unknown-tag } { #1 } }
}
\cs_new_protected:Nn \@@_error_if_flag_undefined:n {
	\yoin_if_flag_defined:nF { #1 } { \msg_error:nnn { yoin } { unknown-flag } { #1 } }
}
%    \end{macrocode}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \section{Environment yoinshell}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Key--value interface to \T{yoinshell}
%    \begin{macrocode}
\keys_define:nn { yoin / yoinshell } {

	flag .code:n =
		\@@_error_if_flag_undefined:n { #1 }
		\bool_if:NT \g_yoin_onlyflags_bool {
			\seq_if_in:NnF \g_yoin_onlyflags_seq { #1 } {
				\keys_set:nn { yoin / yoinshell } {
					ignore = true
				}
			}
		}
		,

	ignore .bool_set:N = \l_yoin_yoinshell_ignore_bool,
	ignore .initial:n = { false },

}
%    \end{macrocode}
% A reasonable shell escape (we use its expandable variant
%    \begin{macrocode}
\file_if_exist:nTF { shellesc.sty } {
	\RequirePackage { shellesc }
} {
	\def \ShellEscape #1 { \immediate \write 18 { #1 } }
}
\cs_new_protected:Nn \@@_yoinshell_shellescape:n {
	\ShellEscape { #1 }
}
\cs_generate_variant:Nn \@@_yoinshell_shellescape:n { x }
%    \end{macrocode}
% Environment \T{yoinshell}:
%    \begin{macrocode}
\cs_new_protected:Nn \yoin_yoinshell_begin:n {
	\group_begin:
	\DeclareDocumentCommand \RunForEach { O{} m } { \yoin_yoinshell_runforeach:nn { ##1 } { ##2 } }
	\DeclareDocumentCommand \Run { O{} m } { \yoin_yoinshell_run:nn { ##1 } { ##2 } }
	\keys_set:nn { yoin / yoinshell } { #1 }
}

\cs_new_protected:Nn \yoin_yoinshell_end: {
	\group_end:
}

\NewDocumentEnvironment { yoinshell } { O{} } {
	\yoin_yoinshell_begin:n { #1 }
} {
	\yoin_yoinshell_end:
}
%    \end{macrocode}
% \T{\\RunForEach}
%    \begin{macrocode}
\tl_new:N \l_@@_yoinshell_runforarticle_tag_tl
\tl_new:N \l_@@_yoinshell_runforeach_onlytag_tl
\tl_set:Nn \l_@@_yoinshell_runforeach_onlytag_tl { \q_no_value }

\keys_define:nn { yoin / runforeach } {
	
	onlytag .code:n =
		\@@_error_if_tag_undefined:n { #1 }
		\tl_set:Nn \l_@@_yoinshell_runforeach_onlytag_tl { #1 }
		,
	
}

\cs_new_protected:Nn \@@_yoinshell_runforarticle:nn {
	\prop_get:cnN { \yoin_article_prop:n { #1 } } { tag } \l_@@_yoinshell_runforarticle_tag_tl
	\bool_if:nT {
		\quark_if_no_value_p:N \l_@@_yoinshell_runforarticle_tag_tl
		||
		\quark_if_no_value_p:N \l_@@_yoinshell_runforeach_onlytag_tl
		||
		\tl_if_eq_p:NN \l_@@_yoinshell_runforeach_onlytag_tl \l_@@_yoinshell_runforarticle_tag_tl
	}{
		\DeclareExpandableDocumentCommand \Article { } { #1 }
		\@@_yoinshell_shellescape:n { #2 }
	}
}

\cs_new_protected:Nn \yoin_yoinshell_runforeach:nn {
	\group_begin:
	\keys_set:nn { yoin / runforeach } { #1 }
	\seq_map_inline:Nn \g_yoin_articles_seq { \@@_yoinshell_runforarticle:nn { ##1 } { #2 } }
	\group_end:
}
%    \end{macrocode}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \section{Article setting stuff}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Information to be stored in an auxiliary file.
%    \begin{macrocode}
\cs_new_protected:Nn \@@_article_write:n {
	\immediate \write \@auxout { \token_to_str:N \@writefile { yoin } { #1 } }
}

\cs_new_protected:Nn \@@_article_write_keyval:nn {
	\@@_article_write:n { #1 ~ = ~ #2 , }
}
\cs_generate_variant:Nn \@@_article_write_keyval:nn { nx }

\cs_new_protected:Nn \yoin_article_write_meta:nn {
	\@@_article_write_keyval:nn { meta-#1 } { #2 }
}

\cs_new_protected:Nn \yoin_article_write_keys: {
	\@@_article_write_keyval:nx { jobname } { \jobname }
	\@@_article_write_keyval:nx { totpages } { \ztotpages }
	\@@_article_write_keyval:nx { currdir } { \l_yoin_article_currdir_tl }
}

\tl_new:N \l_@@_tmpa_tl
\seq_new:N \l_@@_tmpa_seq
\tl_new:N \l_yoin_article_currdir_tl
\cs_new_protected:Nn \yoin_article_getcurrdir:N {
	\tl_set:Nx \l_@@_tmpa_tl { \currfileabsdir }
	\cs_generate_variant:Nn \regex_extract_once:nnNF { nV }
	\regex_extract_once:nVNF { /([^/]+)/\Z } \l_@@_tmpa_tl \l_@@_tmpa_seq { \error }
	\seq_get_right:NN \l_@@_tmpa_seq #1
}

\AtBeginDocument{ \yoin_atbegindocument: }

\cs_new_protected:Nn \yoin_atbegindocument: {
	\expandafter \newwrite \csname tf@yoin\endcsname
	\bool_if:NTF \g_yoin_article_bool {
		\yoin_article_getcurrdir:N \l_yoin_article_currdir_tl
		\immediate \openout \csname tf@yoin\endcsname \l_yoin_article_currdir_tl .yoin\relax
		\yoin_article_write_keys:
	} {
		\immediate \openout \csname tf@yoin\endcsname \jobname .yoin\relax
	}
}

%    \end{macrocode}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \section{Experimental}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%    \begin{macrocode}
\cs_new_protected:Nn \yoin_keys_set_from_file:nn {
	\tl_set_from_file:Nnn \l_tmpa_tl { } { #2 }
	\keys_set:nV { #1 } \l_tmpa_tl
}
\cs_generate_variant:Nn \keys_set:nn { nV }
%    \end{macrocode}
%
%  \begin{macro}{\bla}
%    \begin{macrocode}
\cs_new:Nn \yoin_blabla: {
	Blabla
}

%    \end{macrocode}
%  \end{macro}
%
%    \begin{macrocode}
%</package>
%    \end{macrocode}
%
% \Finale